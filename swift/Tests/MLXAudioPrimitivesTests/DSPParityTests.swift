// DSPParityTests.swift
// Parity tests comparing Swift DSP implementations against Python/librosa reference.
//
// These tests verify numerical correctness by comparing Swift implementations
// to reference data generated by Python (librosa/scipy).
//
// To run these tests:
// 1. Generate reference data from Python:
//    cd python && python tests/parity/generate_swift_dsp_parity_data.py
// 2. Run Swift tests:
//    swift test --filter DSPParityTests
//
// Tests will be skipped if reference data is not found.

import XCTest
import Foundation
@preconcurrency import MLX
@testable import MLXAudioPrimitives

final class DSPParityTests: XCTestCase {

    // MARK: - Configuration

    /// Base directory for parity test data.
    static let parityDataDir = URL(fileURLWithPath: "/tmp/dsp_parity")

    /// Maximum allowed difference for floating point comparisons.
    static let tolerance: Float = 1e-4

    /// Looser tolerance for complex operations (STFT, mel spectrogram).
    static let stftTolerance: Float = 1e-3

    // MARK: - Helper Methods

    /// Load a numpy array from file.
    func loadNpy(_ filename: String) throws -> MLXArray {
        let url = Self.parityDataDir.appendingPathComponent(filename)
        guard FileManager.default.fileExists(atPath: url.path) else {
            throw XCTSkip("""
                Reference file not found: \(filename)
                Generate reference data by running:
                  cd python && python tests/parity/generate_swift_dsp_parity_data.py
                """)
        }
        return try MLX.loadArray(url: url)
    }

    /// Load JSON file as dictionary.
    func loadJson(_ filename: String) throws -> [String: Any] {
        let url = Self.parityDataDir.appendingPathComponent(filename)
        guard FileManager.default.fileExists(atPath: url.path) else {
            throw XCTSkip("Reference file not found: \(filename)")
        }
        let data = try Data(contentsOf: url)
        return try JSONSerialization.jsonObject(with: data) as? [String: Any] ?? [:]
    }

    /// Check if parity data directory exists.
    func checkParityDataExists() throws {
        guard FileManager.default.fileExists(atPath: Self.parityDataDir.path) else {
            throw XCTSkip("""
                Parity test data not found at \(Self.parityDataDir.path).
                Generate it by running:
                  cd python && python tests/parity/generate_swift_dsp_parity_data.py
                """)
        }
    }

    /// Assert two arrays are close within tolerance.
    func assertClose(
        _ actual: MLXArray,
        _ expected: MLXArray,
        rtol: Float = 1e-5,
        atol: Float = 1e-4,
        message: String = ""
    ) {
        // Ensure same shape
        XCTAssertEqual(
            Array(actual.shape),
            Array(expected.shape),
            "Shape mismatch: actual=\(actual.shape) expected=\(expected.shape). \(message)"
        )

        let diff = abs(actual - expected)
        let maxDiff = MLX.max(diff).item(Float.self)
        let meanDiff = mean(diff).item(Float.self)

        let threshold = atol + rtol * MLX.max(abs(expected)).item(Float.self)

        XCTAssertLessThan(
            maxDiff,
            threshold,
            "Max diff: \(maxDiff), Mean diff: \(meanDiff), Threshold: \(threshold). \(message)"
        )
    }

    /// Compute max absolute difference between arrays.
    func maxAbsDiff(_ a: MLXArray, _ b: MLXArray) -> Float {
        return MLX.max(abs(a - b)).item(Float.self)
    }

    /// Compute mean absolute difference between arrays.
    func meanAbsDiff(_ a: MLXArray, _ b: MLXArray) -> Float {
        return mean(abs(a - b)).item(Float.self)
    }

    // MARK: - STFT Parity Tests

    func testSTFTSineWaveParity() throws {
        try checkParityDataExists()

        // Load test signal and reference
        let signal = try loadNpy("sine_440hz_22050sr.npy")
        let expectedMag = try loadNpy("stft_sine_nfft2048_hop512_mag.npy")
        let info = try loadJson("stft_sine_nfft2048_hop512_info.json")

        guard let nFFT = info["n_fft"] as? Int,
              let hopLength = info["hop_length"] as? Int else {
            XCTFail("Could not parse STFT config")
            return
        }

        // Run Swift STFT
        let config = STFTConfig(nFFT: nFFT, hopLength: hopLength, center: true)
        let result = try stft(signal, config: config)
        let actualMag = result.magnitude()

        // Verify shape matches
        let expectedShape = info["shape"] as? [Int] ?? []
        XCTAssertEqual(Array(actualMag.shape), expectedShape, "STFT output shape mismatch")

        // Verify values match
        assertClose(
            actualMag,
            expectedMag,
            atol: Self.stftTolerance,
            message: "STFT sine wave magnitude mismatch"
        )

        print("STFT sine wave parity: max_diff=\(maxAbsDiff(actualMag, expectedMag))")
    }

    func testSTFTDifferentFFTSizes() throws {
        try checkParityDataExists()

        let noise = try loadNpy("noise_seed42_22050.npy")

        for nFFT in [512, 1024, 2048, 4096] {
            let hopLength = nFFT / 4
            let expectedMag = try loadNpy("stft_noise_nfft\(nFFT)_hop\(hopLength)_mag.npy")

            let config = STFTConfig(nFFT: nFFT, hopLength: hopLength, center: true)
            let result = try stft(noise, config: config)
            let actualMag = result.magnitude()

            assertClose(
                actualMag,
                expectedMag,
                atol: Self.stftTolerance,
                message: "STFT nFFT=\(nFFT) magnitude mismatch"
            )

            print("STFT nFFT=\(nFFT) parity: max_diff=\(maxAbsDiff(actualMag, expectedMag))")
        }
    }

    func testSTFTNonCentered() throws {
        try checkParityDataExists()

        let signal = try loadNpy("sine_440hz_22050sr.npy")
        let expectedMag = try loadNpy("stft_sine_nfft1024_hop256_no_center_mag.npy")

        let config = STFTConfig(nFFT: 1024, hopLength: 256, center: false)
        let result = try stft(signal, config: config)
        let actualMag = result.magnitude()

        assertClose(
            actualMag,
            expectedMag,
            atol: Self.stftTolerance,
            message: "STFT non-centered magnitude mismatch"
        )
    }

    func testSTFTWhisperParams() throws {
        try checkParityDataExists()

        let signal = try loadNpy("whisper_test_16000sr.npy")
        let expectedMag = try loadNpy("stft_whisper_nfft400_hop160_mag.npy")

        let config = STFTConfig(nFFT: 400, hopLength: 160, center: true)
        let result = try stft(signal, config: config)
        let actualMag = result.magnitude()

        assertClose(
            actualMag,
            expectedMag,
            atol: Self.stftTolerance,
            message: "STFT Whisper params magnitude mismatch"
        )

        print("STFT Whisper parity: max_diff=\(maxAbsDiff(actualMag, expectedMag))")
    }

    // MARK: - ISTFT Parity Tests

    func testISTFTRoundtrip() throws {
        try checkParityDataExists()

        let input = try loadNpy("istft_roundtrip_input.npy")
        let expectedOutput = try loadNpy("istft_roundtrip_output.npy")
        let info = try loadJson("istft_roundtrip_info.json")

        guard let nFFT = info["n_fft"] as? Int,
              let hopLength = info["hop_length"] as? Int,
              let originalLength = info["original_length"] as? Int else {
            XCTFail("Could not parse ISTFT config")
            return
        }

        // Forward STFT
        let stftConfig = STFTConfig(nFFT: nFFT, hopLength: hopLength, center: true)
        let stftResult = try stft(input, config: stftConfig)

        // Inverse STFT
        let reconstructed = try istft(stftResult, config: stftConfig, length: originalLength)

        // Compare to Python reference
        assertClose(
            reconstructed,
            expectedOutput,
            atol: Self.stftTolerance,
            message: "ISTFT roundtrip mismatch"
        )

        // Also verify reconstruction matches original input
        assertClose(
            reconstructed,
            input,
            atol: Self.stftTolerance,
            message: "ISTFT should reconstruct original signal"
        )

        print("ISTFT roundtrip parity: max_diff=\(maxAbsDiff(reconstructed, expectedOutput))")
    }

    // MARK: - Mel Filterbank Parity Tests

    func testMelFilterbankStandard() throws {
        try checkParityDataExists()

        let expectedFB = try loadNpy("mel_filterbank_standard_slaney.npy")
        let info = try loadJson("mel_filterbank_standard_slaney_info.json")

        guard let sr = info["sr"] as? Int,
              let nFFT = info["n_fft"] as? Int,
              let nMels = info["n_mels"] as? Int else {
            XCTFail("Could not parse mel filterbank config")
            return
        }

        let melConfig = MelConfig(sampleRate: sr, nMels: nMels, norm: .slaney)
        let actualFB = try melFilterbank(nFFT: nFFT, config: melConfig)

        assertClose(
            actualFB,
            expectedFB,
            atol: Self.tolerance,
            message: "Mel filterbank standard slaney mismatch"
        )

        print("Mel filterbank standard parity: max_diff=\(maxAbsDiff(actualFB, expectedFB))")
    }

    func testMelFilterbankWhisper() throws {
        try checkParityDataExists()

        let expectedFB = try loadNpy("mel_filterbank_whisper_slaney.npy")

        // Whisper parameters: sr=16000, n_fft=400, n_mels=80
        let melConfig = MelConfig(sampleRate: 16000, nMels: 80, norm: .slaney)
        let actualFB = try melFilterbank(nFFT: 400, config: melConfig)

        assertClose(
            actualFB,
            expectedFB,
            atol: Self.tolerance,
            message: "Mel filterbank whisper mismatch"
        )

        print("Mel filterbank Whisper parity: max_diff=\(maxAbsDiff(actualFB, expectedFB))")
    }

    func testMelFilterbankNoNorm() throws {
        try checkParityDataExists()

        let expectedFB = try loadNpy("mel_filterbank_standard_none.npy")
        let info = try loadJson("mel_filterbank_standard_none_info.json")

        guard let sr = info["sr"] as? Int,
              let nFFT = info["n_fft"] as? Int,
              let nMels = info["n_mels"] as? Int else {
            XCTFail("Could not parse mel filterbank config")
            return
        }

        let melConfig = MelConfig(sampleRate: sr, nMels: nMels, norm: nil)
        let actualFB = try melFilterbank(nFFT: nFFT, config: melConfig)

        assertClose(
            actualFB,
            expectedFB,
            atol: Self.tolerance,
            message: "Mel filterbank no norm mismatch"
        )
    }

    // MARK: - Mel Spectrogram Parity Tests

    func testMelSpectrogramStandard() throws {
        try checkParityDataExists()

        let signal = try loadNpy("noise_seed42_22050.npy")
        let expectedMel = try loadNpy("mel_spectrogram_standard.npy")
        let info = try loadJson("mel_spectrogram_standard_info.json")

        guard let sr = info["sr"] as? Int,
              let nFFT = info["n_fft"] as? Int,
              let hopLength = info["hop_length"] as? Int,
              let nMels = info["n_mels"] as? Int else {
            XCTFail("Could not parse mel spectrogram config")
            return
        }

        let melConfig = MelConfig(sampleRate: sr, nMels: nMels)
        let actualMel = try melspectrogram(
            signal,
            nFFT: nFFT,
            hopLength: hopLength,
            melConfig: melConfig
        )

        assertClose(
            actualMel,
            expectedMel,
            atol: Self.stftTolerance,
            message: "Mel spectrogram standard mismatch"
        )

        print("Mel spectrogram parity: max_diff=\(maxAbsDiff(actualMel, expectedMel))")
    }

    func testMelSpectrogramWhisper() throws {
        try checkParityDataExists()

        let signal = try loadNpy("whisper_test_16000sr.npy")
        let expectedMel = try loadNpy("mel_spectrogram_whisper.npy")

        let melConfig = MelConfig(sampleRate: 16000, nMels: 80)
        let actualMel = try melspectrogram(
            signal,
            nFFT: 400,
            hopLength: 160,
            melConfig: melConfig
        )

        assertClose(
            actualMel,
            expectedMel,
            atol: Self.stftTolerance,
            message: "Mel spectrogram Whisper mismatch"
        )

        print("Mel spectrogram Whisper parity: max_diff=\(maxAbsDiff(actualMel, expectedMel))")
    }

    // MARK: - Window Function Parity Tests

    func testWindowHann() throws {
        try checkParityDataExists()

        for size in [256, 512, 1024, 2048] {
            let expectedWindow = try loadNpy("window_hann_\(size).npy")
            // Use getWindow with periodic=true to match scipy.signal.get_window behavior
            let actualWindow = getWindow(.hann, length: size, periodic: true)

            assertClose(
                actualWindow,
                expectedWindow,
                atol: Self.tolerance,
                message: "Hann window size=\(size) mismatch"
            )
        }
    }

    func testWindowHamming() throws {
        try checkParityDataExists()

        for size in [256, 512, 1024, 2048] {
            let expectedWindow = try loadNpy("window_hamming_\(size).npy")
            let actualWindow = getWindow(.hamming, length: size, periodic: true)

            assertClose(
                actualWindow,
                expectedWindow,
                atol: Self.tolerance,
                message: "Hamming window size=\(size) mismatch"
            )
        }
    }

    func testWindowBlackman() throws {
        try checkParityDataExists()

        for size in [256, 512, 1024, 2048] {
            let expectedWindow = try loadNpy("window_blackman_\(size).npy")
            let actualWindow = getWindow(.blackman, length: size, periodic: true)

            assertClose(
                actualWindow,
                expectedWindow,
                atol: Self.tolerance,
                message: "Blackman window size=\(size) mismatch"
            )
        }
    }

    // MARK: - MFCC Parity Tests

    func testMFCCStandard() throws {
        try checkParityDataExists()

        let signal = try loadNpy("noise_seed42_22050.npy")
        let expectedMFCC = try loadNpy("mfcc_standard_13.npy")
        let info = try loadJson("mfcc_standard_13_info.json")

        guard let sr = info["sr"] as? Int,
              let nMFCC = info["n_mfcc"] as? Int else {
            XCTFail("Could not parse MFCC config")
            return
        }

        let mfccConfig = MFCCConfig(nMFCC: nMFCC)
        let actualMFCC = try mfcc(signal, sampleRate: sr, mfccConfig: mfccConfig)

        // Shape should match
        let expectedShape = info["shape"] as? [Int] ?? []
        XCTAssertEqual(Array(actualMFCC.shape), expectedShape, "MFCC shape mismatch")

        assertClose(
            actualMFCC,
            expectedMFCC,
            atol: Self.stftTolerance,
            message: "MFCC standard mismatch"
        )

        print("MFCC parity: max_diff=\(maxAbsDiff(actualMFCC, expectedMFCC))")
    }

    func testMFCC40Coefficients() throws {
        try checkParityDataExists()

        let signal = try loadNpy("noise_seed42_22050.npy")
        let expectedMFCC = try loadNpy("mfcc_standard_40.npy")

        let mfccConfig = MFCCConfig(nMFCC: 40)
        let actualMFCC = try mfcc(signal, sampleRate: 22050, mfccConfig: mfccConfig)

        assertClose(
            actualMFCC,
            expectedMFCC,
            atol: Self.stftTolerance,
            message: "MFCC 40 coefficients mismatch"
        )
    }
}

// MARK: - Numerical Accuracy Report

extension DSPParityTests {

    /// Run all parity tests and generate accuracy report.
    /// This is a meta-test that summarizes parity test results.
    func testGenerateParityReport() throws {
        try checkParityDataExists()

        var report: [(String, Float, Float)] = []  // (test_name, max_diff, mean_diff)

        // STFT tests
        do {
            let signal = try loadNpy("sine_440hz_22050sr.npy")
            let expectedMag = try loadNpy("stft_sine_nfft2048_hop512_mag.npy")
            let config = STFTConfig(nFFT: 2048, hopLength: 512, center: true)
            let result = try stft(signal, config: config)
            let actualMag = result.magnitude()
            report.append(("STFT Sine 2048", maxAbsDiff(actualMag, expectedMag), meanAbsDiff(actualMag, expectedMag)))
        } catch {
            // Skip if data not available
        }

        // Mel filterbank tests
        do {
            let expectedFB = try loadNpy("mel_filterbank_standard_slaney.npy")
            let melConfig = MelConfig(sampleRate: 22050, nMels: 128, norm: .slaney)
            let actualFB = try melFilterbank(nFFT: 2048, config: melConfig)
            report.append(("Mel Filterbank", maxAbsDiff(actualFB, expectedFB), meanAbsDiff(actualFB, expectedFB)))
        } catch {
            // Skip if data not available
        }

        // Print report
        if !report.isEmpty {
            print("\n========== DSP Parity Report ==========")
            print(String(format: "%-25s %12s %12s", "Test", "Max Diff", "Mean Diff"))
            print(String(repeating: "-", count: 51))
            for (name, maxDiff, meanDiff) in report {
                print(String(format: "%-25s %12.2e %12.2e", name, maxDiff, meanDiff))
            }
            print("========================================\n")
        }
    }
}
