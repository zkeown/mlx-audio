// EnCodecParityTests.swift
// Parity tests comparing Swift EnCodec implementation against Python.
//
// These tests load fixtures generated by:
//   python tests/generate_encodec_fixtures.py --output-dir swift/Tests/Fixtures/EnCodec
//
// Run from the python/ directory to generate fixtures before running these tests.

import XCTest
@testable import MLXAudioModels
import MLX
import MLXNN

/// Parity tests for EnCodec Swift implementation.
///
/// These tests compare Swift outputs against Python-generated fixtures
/// to ensure numerical equivalence within tolerance.
final class EnCodecParityTests: XCTestCase {

    // MARK: - Test Configuration

    /// Tolerance for individual layer tests
    static let layerTolerance: Float = 1e-5

    /// Tolerance for multi-layer chains (accumulated error)
    static let chainTolerance: Float = 1e-4

    /// Tolerance for full model tests
    static let modelTolerance: Float = 1e-3

    /// Path to fixtures directory
    static var fixturesPath: URL {
        // Try environment variable first
        if let envPath = ProcessInfo.processInfo.environment["ENCODEC_FIXTURES_PATH"] {
            return URL(fileURLWithPath: envPath)
        }

        // Common fixture locations to check
        let possiblePaths = [
            // Relative to source file
            URL(fileURLWithPath: #filePath)
                .deletingLastPathComponent()  // EnCodecParityTests.swift
                .deletingLastPathComponent()  // MLXAudioModelsTests
                .deletingLastPathComponent()  // Tests
                .appendingPathComponent("Fixtures")
                .appendingPathComponent("EnCodec"),

            // Current working directory patterns
            URL(fileURLWithPath: FileManager.default.currentDirectoryPath)
                .appendingPathComponent("Tests")
                .appendingPathComponent("Fixtures")
                .appendingPathComponent("EnCodec"),

            URL(fileURLWithPath: FileManager.default.currentDirectoryPath)
                .appendingPathComponent("swift")
                .appendingPathComponent("Tests")
                .appendingPathComponent("Fixtures")
                .appendingPathComponent("EnCodec"),

            // Common development paths
            URL(fileURLWithPath: NSHomeDirectory())
                .appendingPathComponent("Code/mlx-audio/swift/Tests/Fixtures/EnCodec"),
        ]

        for path in possiblePaths {
            if FileManager.default.fileExists(atPath: path.path) {
                return path
            }
        }

        // Default fallback
        return possiblePaths[0]
    }

    /// Check if fixtures are available
    static var fixturesAvailable: Bool {
        FileManager.default.fileExists(atPath: fixturesPath.path)
    }

    // MARK: - Helper Methods

    /// Load arrays from a safetensors fixture file.
    func loadFixture(_ name: String) throws -> [String: MLXArray] {
        let url = Self.fixturesPath.appendingPathComponent("\(name).safetensors")
        guard FileManager.default.fileExists(atPath: url.path) else {
            throw EnCodecParityTestError.fixtureNotFound(name)
        }
        return try MLX.loadArrays(url: url)
    }

    /// Calculate maximum absolute difference between two arrays.
    func maxAbsDiff(_ a: MLXArray, _ b: MLXArray) -> Float {
        let diff = abs(a - b)
        return diff.max().item(Float.self)
    }

    /// Assert arrays are equal within tolerance.
    func assertArraysEqual(
        _ actual: MLXArray,
        _ expected: MLXArray,
        tolerance: Float,
        message: String = "",
        file: StaticString = #file,
        line: UInt = #line
    ) {
        let diff = maxAbsDiff(actual, expected)
        XCTAssertLessThan(
            diff,
            tolerance,
            "Arrays differ by \(diff), exceeds tolerance \(tolerance). \(message)",
            file: file,
            line: line
        )
    }

    /// Skip test if fixtures not available.
    func skipIfNoFixtures(file: StaticString = #file, line: UInt = #line) throws {
        try XCTSkipUnless(
            Self.fixturesAvailable,
            "Fixtures not found at \(Self.fixturesPath.path). Run: python tests/generate_encodec_fixtures.py",
            file: file,
            line: line
        )
    }

    // MARK: - Vector Quantizer Parity Tests

    func testVectorQuantizerParity() throws {
        try skipIfNoFixtures()

        let fixtures = try loadFixture("vector_quantizer")
        let weights = try loadFixture("vector_quantizer_weights")

        let input = fixtures["input"]!
        let expectedQuantized = fixtures["quantized"]!
        let expectedCodes = fixtures["codes"]!

        // Create VQ with same config as fixtures
        let vq = VectorQuantizer(codebookSize: 1024, codebookDim: 128)
        try vq.update(parameters: ModuleParameters.unflattened(weights), verify: .noUnusedKeys)

        // Run forward pass
        let (quantized, codes) = vq(input)

        // Compare codes (should match exactly)
        XCTAssertEqual(codes.shape, expectedCodes.shape, "Codes shape mismatch")

        // Compare quantized embeddings
        assertArraysEqual(
            quantized,
            expectedQuantized,
            tolerance: Self.layerTolerance,
            message: "VQ quantized output mismatch"
        )
    }

    func testRVQParity() throws {
        try skipIfNoFixtures()

        let fixtures = try loadFixture("rvq")
        let weights = try loadFixture("rvq_weights")

        let input = fixtures["input"]!
        let expectedQuantized = fixtures["quantized"]!
        let expectedCodes = fixtures["codes"]!

        // Create RVQ
        let rvq = ResidualVectorQuantizer(
            numCodebooks: 8,  // Match 24kHz config
            codebookSize: 1024,
            codebookDim: 128
        )
        try rvq.update(parameters: ModuleParameters.unflattened(weights), verify: .noUnusedKeys)

        // Run forward pass
        let (quantized, codes) = rvq(input)

        // Compare shapes
        XCTAssertEqual(codes.shape, expectedCodes.shape, "RVQ codes shape mismatch")

        // Compare quantized embeddings
        assertArraysEqual(
            quantized,
            expectedQuantized,
            tolerance: Self.chainTolerance,
            message: "RVQ quantized output mismatch"
        )
    }

    // MARK: - Encoder Parity Tests

    func testEncoderParity() throws {
        try skipIfNoFixtures()

        let fixtures = try loadFixture("encoder")
        let weights = try loadFixture("encoder_weights")

        let input = fixtures["input"]!
        let expectedOutput = fixtures["output"]!

        // Load config
        let configURL = Self.fixturesPath.appendingPathComponent("config.json")
        let configData = try Data(contentsOf: configURL)
        let config = try JSONDecoder().decode(EnCodecConfig.self, from: configData)

        // Create encoder
        let encoder = EnCodecEncoder(config: config)
        try encoder.update(parameters: ModuleParameters.unflattened(weights), verify: .noUnusedKeys)

        // Run forward pass
        let output = encoder(input)

        // Compare
        assertArraysEqual(
            output,
            expectedOutput,
            tolerance: Self.chainTolerance,
            message: "Encoder output mismatch"
        )
    }

    // MARK: - Decoder Parity Tests

    func testDecoderParity() throws {
        try skipIfNoFixtures()

        let fixtures = try loadFixture("decoder")
        let weights = try loadFixture("decoder_weights")

        let input = fixtures["input"]!
        let expectedOutput = fixtures["output"]!

        // Load config
        let configURL = Self.fixturesPath.appendingPathComponent("config.json")
        let configData = try Data(contentsOf: configURL)
        let config = try JSONDecoder().decode(EnCodecConfig.self, from: configData)

        // Create decoder
        let decoder = EnCodecDecoder(config: config)
        try decoder.update(parameters: ModuleParameters.unflattened(weights), verify: .noUnusedKeys)

        // Run forward pass
        let output = decoder(input)

        // Compare
        assertArraysEqual(
            output,
            expectedOutput,
            tolerance: Self.chainTolerance,
            message: "Decoder output mismatch"
        )
    }

    // MARK: - Full Model Parity Tests

    func testSmallModelParity() throws {
        try skipIfNoFixtures()

        let fixtures = try loadFixture("small_model")
        let weights = try loadFixture("small_model_weights")

        let input = fixtures["input"]!
        let expectedReconstructed = fixtures["reconstructed"]!
        let expectedCodes = fixtures["codes"]!

        // Load config
        let configURL = Self.fixturesPath.appendingPathComponent("small_model_config.json")
        let configData = try Data(contentsOf: configURL)
        let config = try JSONDecoder().decode(EnCodecConfig.self, from: configData)

        // Create model
        let model = EnCodec(config: config)
        try model.update(parameters: ModuleParameters.unflattened(weights), verify: .noUnusedKeys)

        // Run forward pass
        let (reconstructed, codes) = model(input)

        // Compare codes shape
        XCTAssertEqual(codes.shape, expectedCodes.shape, "Codes shape mismatch")

        // Compare reconstructed audio
        assertArraysEqual(
            reconstructed,
            expectedReconstructed,
            tolerance: Self.modelTolerance,
            message: "Small model reconstructed output mismatch"
        )
    }

    func testFullModelParity() throws {
        try skipIfNoFixtures()

        // Check if full model fixtures exist
        let fullModelPath = Self.fixturesPath.appendingPathComponent("full_model.safetensors")
        try XCTSkipUnless(
            FileManager.default.fileExists(atPath: fullModelPath.path),
            "Full model fixtures not found. Run: python tests/generate_encodec_fixtures.py"
        )

        let fixtures = try loadFixture("full_model")
        let weights = try loadFixture("full_model_weights")

        let input = fixtures["input"]!
        let expectedReconstructed = fixtures["reconstructed"]!
        let expectedCodes = fixtures["codes"]!

        // Load config
        let configURL = Self.fixturesPath.appendingPathComponent("config.json")
        let configData = try Data(contentsOf: configURL)
        let config = try JSONDecoder().decode(EnCodecConfig.self, from: configData)

        // Create model
        let model = EnCodec(config: config)
        try model.update(parameters: ModuleParameters.unflattened(weights), verify: .noUnusedKeys)

        // Run forward pass
        let (reconstructed, codes) = model(input)

        // Compare codes shape
        XCTAssertEqual(codes.shape, expectedCodes.shape, "Codes shape mismatch")

        // Compare reconstructed audio
        assertArraysEqual(
            reconstructed,
            expectedReconstructed,
            tolerance: Self.modelTolerance,
            message: "Full model reconstructed output mismatch"
        )
    }

    // MARK: - Shape Consistency Tests

    func testOutputShapeConsistency() throws {
        try skipIfNoFixtures()

        let fixtures = try loadFixture("small_model")

        let input = fixtures["input"]!
        let expectedReconstructed = fixtures["reconstructed"]!
        let expectedCodes = fixtures["codes"]!

        let configURL = Self.fixturesPath.appendingPathComponent("small_model_config.json")
        let configData = try Data(contentsOf: configURL)
        let config = try JSONDecoder().decode(EnCodecConfig.self, from: configData)

        let model = EnCodec(config: config)
        let (reconstructed, codes) = model(input)

        XCTAssertEqual(
            reconstructed.shape,
            expectedReconstructed.shape,
            "Reconstructed shape mismatch: Swift \(reconstructed.shape) vs Python \(expectedReconstructed.shape)"
        )

        XCTAssertEqual(
            codes.shape,
            expectedCodes.shape,
            "Codes shape mismatch: Swift \(codes.shape) vs Python \(expectedCodes.shape)"
        )
    }

    // MARK: - Encode/Decode Consistency Tests

    func testEncodeDecodeConsistency() throws {
        try skipIfNoFixtures()

        let fixtures = try loadFixture("full_model")
        let weights = try loadFixture("full_model_weights")

        let input = fixtures["input"]!

        // Load config
        let configURL = Self.fixturesPath.appendingPathComponent("config.json")
        let configData = try Data(contentsOf: configURL)
        let config = try JSONDecoder().decode(EnCodecConfig.self, from: configData)

        // Create model
        let model = EnCodec(config: config)
        try model.update(parameters: ModuleParameters.unflattened(weights), verify: .noUnusedKeys)

        // Encode
        let codes = model.encode(input)

        // Decode
        let reconstructed = model.decode(codes)

        // Verify roundtrip produces same result as single forward pass
        let (reconstructed2, codes2) = model(input)

        assertArraysEqual(
            codes,
            codes2,
            tolerance: 0,  // Should be exactly equal
            message: "Encode should produce same codes as forward pass"
        )

        assertArraysEqual(
            reconstructed,
            reconstructed2,
            tolerance: Self.layerTolerance,
            message: "Separate encode/decode should match forward pass"
        )
    }
}

// MARK: - Errors

enum EnCodecParityTestError: Error, LocalizedError {
    case fixtureNotFound(String)

    var errorDescription: String? {
        switch self {
        case .fixtureNotFound(let name):
            return "Fixture not found: \(name).safetensors"
        }
    }
}

// MARK: - Performance Tests

extension EnCodecParityTests {

    /// Benchmark encode performance.
    func testEncodePerformance() throws {
        // Use small config for benchmark
        let config = EnCodecConfig(
            channels: 1,
            num_codebooks: 4,
            num_filters: 32,
            ratios: [8, 5, 4, 2],
            lstm_layers: 0  // No LSTM for faster benchmark
        )

        let model = EnCodec(config: config)
        let input = MLXRandom.normal([1, 1, 32000])  // 1 second audio

        // Warmup
        _ = model.encode(input)
        eval()

        measure {
            let _ = model.encode(input)
            eval()
        }
    }

    /// Benchmark decode performance.
    func testDecodePerformance() throws {
        let config = EnCodecConfig(
            channels: 1,
            num_codebooks: 4,
            num_filters: 32,
            ratios: [8, 5, 4, 2],
            lstm_layers: 0
        )

        let model = EnCodec(config: config)

        // Create codes for 1 second of audio
        let numFrames = 32000 / config.hop_length
        let codes = MLXRandom.randInt(
            low: 0,
            high: config.codebook_size,
            [1, config.num_codebooks, numFrames]
        )

        // Warmup
        _ = model.decode(codes)
        eval()

        measure {
            let _ = model.decode(codes)
            eval()
        }
    }

    /// Benchmark full roundtrip performance.
    func testRoundtripPerformance() throws {
        let config = EnCodecConfig(
            channels: 1,
            num_codebooks: 4,
            num_filters: 32,
            ratios: [8, 5, 4, 2],
            lstm_layers: 0
        )

        let model = EnCodec(config: config)
        let input = MLXRandom.normal([1, 1, 32000])

        // Warmup
        let _ = model(input)
        eval()

        measure {
            let _ = model(input)
            eval()
        }
    }
}
