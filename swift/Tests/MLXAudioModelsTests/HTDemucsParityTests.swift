// HTDemucsParityTests.swift
// Parity tests comparing Swift HTDemucs implementation against Python.
//
// These tests load fixtures generated by:
//   python tests/generate_swift_fixtures.py --output-dir swift/Tests/Fixtures/HTDemucs
//
// Run from the python/ directory to generate fixtures before running these tests.

import XCTest
@testable import MLXAudioModels
@testable import MLXAudioPrimitives
import MLX
import MLXNN

/// Parity tests for HTDemucs Swift implementation.
///
/// These tests compare Swift outputs against Python-generated fixtures
/// to ensure numerical equivalence within tolerance.
final class HTDemucsParityTests: XCTestCase {

    // MARK: - Test Configuration

    /// Tolerance for individual layer tests
    static let layerTolerance: Float = 1e-5

    /// Tolerance for multi-layer chains (accumulated error)
    static let chainTolerance: Float = 1e-4

    /// Tolerance for full model tests
    static let modelTolerance: Float = 1e-3

    /// Path to fixtures directory
    static var fixturesPath: URL {
        // Try environment variable first
        if let envPath = ProcessInfo.processInfo.environment["HTDEMUCS_FIXTURES_PATH"] {
            return URL(fileURLWithPath: envPath)
        }

        // Common fixture locations to check
        let possiblePaths = [
            // Relative to source file (when #filePath points to actual source)
            URL(fileURLWithPath: #filePath)
                .deletingLastPathComponent()  // HTDemucsParityTests.swift
                .deletingLastPathComponent()  // MLXAudioModelsTests
                .deletingLastPathComponent()  // Tests
                .appendingPathComponent("Fixtures")
                .appendingPathComponent("HTDemucs"),

            // Current working directory patterns
            URL(fileURLWithPath: FileManager.default.currentDirectoryPath)
                .appendingPathComponent("Tests")
                .appendingPathComponent("Fixtures")
                .appendingPathComponent("HTDemucs"),

            URL(fileURLWithPath: FileManager.default.currentDirectoryPath)
                .appendingPathComponent("swift")
                .appendingPathComponent("Tests")
                .appendingPathComponent("Fixtures")
                .appendingPathComponent("HTDemucs"),

            // Common development paths
            URL(fileURLWithPath: "/Users")
                .appendingPathComponent(NSUserName())
                .appendingPathComponent("Code/mlx-audio/swift/Tests/Fixtures/HTDemucs"),

            URL(fileURLWithPath: NSHomeDirectory())
                .appendingPathComponent("Code/mlx-audio/swift/Tests/Fixtures/HTDemucs"),
        ]

        for path in possiblePaths {
            if FileManager.default.fileExists(atPath: path.path) {
                return path
            }
        }

        // Default fallback (will fail gracefully in tests)
        return possiblePaths[0]
    }

    /// Check if fixtures are available
    static var fixturesAvailable: Bool {
        FileManager.default.fileExists(atPath: fixturesPath.path)
    }

    // MARK: - Helper Methods

    /// Load arrays from a safetensors fixture file.
    func loadFixture(_ name: String) throws -> [String: MLXArray] {
        let url = Self.fixturesPath.appendingPathComponent("\(name).safetensors")
        guard FileManager.default.fileExists(atPath: url.path) else {
            throw ParityTestError.fixtureNotFound(name)
        }
        return try MLX.loadArrays(url: url)
    }

    /// Calculate maximum absolute difference between two arrays.
    func maxAbsDiff(_ a: MLXArray, _ b: MLXArray) -> Float {
        let diff = abs(a - b)
        return diff.max().item(Float.self)
    }

    /// Assert arrays are equal within tolerance.
    func assertArraysEqual(
        _ actual: MLXArray,
        _ expected: MLXArray,
        tolerance: Float,
        message: String = "",
        file: StaticString = #file,
        line: UInt = #line
    ) {
        let diff = maxAbsDiff(actual, expected)
        XCTAssertLessThan(
            diff,
            tolerance,
            "Arrays differ by \(diff), exceeds tolerance \(tolerance). \(message)",
            file: file,
            line: line
        )
    }

    /// Skip test if fixtures not available.
    func skipIfNoFixtures(file: StaticString = #file, line: UInt = #line) throws {
        try XCTSkipUnless(
            Self.fixturesAvailable,
            "Fixtures not found at \(Self.fixturesPath.path). Run: python tests/generate_swift_fixtures.py",
            file: file,
            line: line
        )
    }

    // MARK: - DConv Parity Tests

    func testDConvParity() throws {
        try skipIfNoFixtures()

        // Load fixtures
        let fixtures = try loadFixture("dconv")
        let weights = try loadFixture("dconv_weights")

        let input = fixtures["input"]!
        let expectedOutput = fixtures["output"]!

        // Create DConv and load weights
        let dconv = DConv(channels: 48, depth: 2, compress: 8)
        try dconv.update(parameters: ModuleParameters.unflattened(weights), verify: .noUnusedKeys)

        // Run forward pass
        let output = dconv(input)

        // Compare
        assertArraysEqual(
            output,
            expectedOutput,
            tolerance: Self.layerTolerance,
            message: "DConv output mismatch"
        )
    }

    // MARK: - Encoder Parity Tests

    func testFrequencyEncoderParity() throws {
        try skipIfNoFixtures()

        let fixtures = try loadFixture("freq_encoder")
        let weights = try loadFixture("freq_encoder_weights")

        // Fixtures are in NCHW format, convert to NHWC for encoder
        let inputNCHW = fixtures["input"]!
        let expectedOutputNCHW = fixtures["output"]!

        // Convert NCHW -> NHWC: [B, C, F, T] -> [B, F, T, C]
        let inputNHWC = inputNCHW.transposed(0, 2, 3, 1)

        let encoder = HEncLayer(
            chin: 4,
            chout: 48,
            kernelSize: 8,
            stride: 4,
            freq: true,
            dconvDepth: 2,
            dconvCompress: 8
        )
        try encoder.update(parameters: ModuleParameters.unflattened(weights), verify: .noUnusedKeys)

        let outputNHWC = encoder(inputNHWC)

        // Convert output back to NCHW for comparison: [B, F, T, C] -> [B, C, F, T]
        let output = outputNHWC.transposed(0, 3, 1, 2)

        assertArraysEqual(
            output,
            expectedOutputNCHW,
            tolerance: Self.layerTolerance,
            message: "Frequency encoder output mismatch"
        )
    }

    func testTimeEncoderParity() throws {
        try skipIfNoFixtures()

        let fixtures = try loadFixture("time_encoder")
        let weights = try loadFixture("time_encoder_weights")

        // Fixtures are in NCL format, convert to NLC for encoder
        let inputNCL = fixtures["input"]!
        let expectedOutputNCL = fixtures["output"]!

        // Convert NCL -> NLC: [B, C, T] -> [B, T, C]
        let inputNLC = inputNCL.transposed(0, 2, 1)

        let encoder = HEncLayer(
            chin: 2,
            chout: 48,
            kernelSize: 8,
            stride: 4,
            freq: false,
            dconvDepth: 2,
            dconvCompress: 8
        )
        try encoder.update(parameters: ModuleParameters.unflattened(weights), verify: .noUnusedKeys)

        let outputNLC = encoder(inputNLC)

        // Convert output back to NCL for comparison: [B, T, C] -> [B, C, T]
        let output = outputNLC.transposed(0, 2, 1)

        assertArraysEqual(
            output,
            expectedOutputNCL,
            tolerance: Self.layerTolerance,
            message: "Time encoder output mismatch"
        )
    }

    // MARK: - Decoder Parity Tests

    func testFrequencyDecoderParity() throws {
        try skipIfNoFixtures()

        let fixtures = try loadFixture("freq_decoder")
        let weights = try loadFixture("freq_decoder_weights")

        // Fixtures are in NCHW format, convert to NHWC for decoder
        let inputNCHW = fixtures["input"]!
        let skipNCHW = fixtures["skip"]!
        let expectedOutputNCHW = fixtures["output"]!

        // Convert NCHW -> NHWC: [B, C, F, T] -> [B, F, T, C]
        let inputNHWC = inputNCHW.transposed(0, 2, 3, 1)
        let skipNHWC = skipNCHW.transposed(0, 2, 3, 1)

        let decoder = HDecLayer(
            chin: 48,
            chout: 4,
            kernelSize: 8,
            stride: 4,
            freq: true,
            dconvDepth: 2,
            dconvCompress: 8,
            last: true
        )
        try decoder.update(parameters: ModuleParameters.unflattened(weights), verify: .noUnusedKeys)

        let (outputNHWC, _) = decoder(inputNHWC, skip: skipNHWC, length: 65)

        // Convert output back to NCHW for comparison: [B, F, T, C] -> [B, C, F, T]
        let output = outputNHWC.transposed(0, 3, 1, 2)

        assertArraysEqual(
            output,
            expectedOutputNCHW,
            tolerance: Self.layerTolerance,
            message: "Frequency decoder output mismatch"
        )
    }

    func testTimeDecoderParity() throws {
        try skipIfNoFixtures()

        let fixtures = try loadFixture("time_decoder")
        let weights = try loadFixture("time_decoder_weights")

        // Fixtures are in NCL format, convert to NLC for decoder
        let inputNCL = fixtures["input"]!
        let skipNCL = fixtures["skip"]!
        let length = fixtures["length"]!.item(Int.self)
        let expectedOutputNCL = fixtures["output"]!

        // Convert NCL -> NLC: [B, C, T] -> [B, T, C]
        let inputNLC = inputNCL.transposed(0, 2, 1)
        let skipNLC = skipNCL.transposed(0, 2, 1)

        let decoder = HDecLayer(
            chin: 48,
            chout: 2,
            kernelSize: 8,
            stride: 4,
            freq: false,
            dconvDepth: 2,
            dconvCompress: 8,
            last: true
        )
        try decoder.update(parameters: ModuleParameters.unflattened(weights), verify: .noUnusedKeys)

        let (outputNLC, _) = decoder(inputNLC, skip: skipNLC, length: length)

        // Convert output back to NCL for comparison: [B, T, C] -> [B, C, T]
        let output = outputNLC.transposed(0, 2, 1)

        assertArraysEqual(
            output,
            expectedOutputNCL,
            tolerance: Self.layerTolerance,
            message: "Time decoder output mismatch"
        )
    }

    // MARK: - Transformer Parity Tests

    func testMultiheadAttentionParity() throws {
        try skipIfNoFixtures()

        let fixtures = try loadFixture("multihead_attention")
        let weights = try loadFixture("multihead_attention_weights")

        let query = fixtures["query"]!
        let key = fixtures["key"]!
        let value = fixtures["value"]!
        let expectedOutput = fixtures["output"]!

        let mha = MultiheadAttention(embedDim: 512, numHeads: 8)
        try mha.update(parameters: ModuleParameters.unflattened(weights), verify: .noUnusedKeys)

        let output = mha(query: query, key: key, value: value)

        assertArraysEqual(
            output,
            expectedOutput,
            tolerance: Self.layerTolerance,
            message: "MultiheadAttention output mismatch"
        )
    }

    func testCrossTransformerParity() throws {
        try skipIfNoFixtures()

        let fixtures = try loadFixture("cross_transformer")
        let weights = try loadFixture("cross_transformer_weights")

        let freqInput = fixtures["freq_input"]!
        let timeInput = fixtures["time_input"]!
        let expectedFreqOutput = fixtures["freq_output"]!
        let expectedTimeOutput = fixtures["time_output"]!

        let transformer = CrossTransformerEncoder(
            dim: 512,
            depth: 5,
            heads: 8,
            dimFeedforward: 2048
        )
        try transformer.update(parameters: ModuleParameters.unflattened(weights), verify: .noUnusedKeys)

        let (freqOutput, timeOutput) = transformer(freq: freqInput, time: timeInput)

        assertArraysEqual(
            freqOutput,
            expectedFreqOutput,
            tolerance: Self.chainTolerance,
            message: "CrossTransformer freq output mismatch"
        )
        assertArraysEqual(
            timeOutput,
            expectedTimeOutput,
            tolerance: Self.chainTolerance,
            message: "CrossTransformer time output mismatch"
        )
    }

    // MARK: - STFT Parity Tests

    func testSTFTParity() throws {
        try skipIfNoFixtures()

        let fixtures = try loadFixture("stft")

        let audio = fixtures["audio"]!
        let expectedReal = fixtures["spec_normalized_real"]!
        let expectedImag = fixtures["spec_normalized_imag"]!

        // Compute STFT using Swift primitives
        let config = STFTConfig(
            nFFT: 4096,
            hopLength: 1024,
            padMode: .edge  // Note: Python may use .reflect
        )
        let spec = try stft(audio, config: config)

        // Normalize like HTDemucs
        let normFactor = Float(sqrt(Double(4096)))
        let normalizedReal = spec.real / normFactor
        let normalizedImag = spec.imag / normFactor

        // Note: We expect some difference due to padding mode
        // Using higher tolerance for STFT comparison
        let stftTolerance: Float = 1e-3

        assertArraysEqual(
            normalizedReal,
            expectedReal,
            tolerance: stftTolerance,
            message: "STFT real part mismatch (may differ due to padding mode)"
        )
        assertArraysEqual(
            normalizedImag,
            expectedImag,
            tolerance: stftTolerance,
            message: "STFT imaginary part mismatch (may differ due to padding mode)"
        )
    }

    // MARK: - Full Model Parity Tests

    func testSmallModelParity() throws {
        try skipIfNoFixtures()

        let fixtures = try loadFixture("small_model")
        let weights = try loadFixture("small_model_weights")

        let input = fixtures["input"]!
        let expectedOutput = fixtures["output"]!

        // Load config
        let configURL = Self.fixturesPath.appendingPathComponent("small_model_config.json")
        let configData = try Data(contentsOf: configURL)
        let config = try JSONDecoder().decode(HTDemucsConfig.self, from: configData)

        let model = HTDemucs(config: config)
        try model.update(parameters: ModuleParameters.unflattened(weights), verify: .noUnusedKeys)

        let output = model(input)

        assertArraysEqual(
            output,
            expectedOutput,
            tolerance: Self.modelTolerance,
            message: "Small model output mismatch"
        )
    }

    func testFullModelParity() throws {
        try skipIfNoFixtures()

        // Check if full model fixtures exist
        let fullModelPath = Self.fixturesPath.appendingPathComponent("full_model.safetensors")
        try XCTSkipUnless(
            FileManager.default.fileExists(atPath: fullModelPath.path),
            "Full model fixtures not found. Run: python tests/generate_swift_fixtures.py"
        )

        let fixtures = try loadFixture("full_model")
        let weights = try loadFixture("full_model_weights")

        let input = fixtures["input"]!
        let expectedOutput = fixtures["output"]!

        // Load config
        let configURL = Self.fixturesPath.appendingPathComponent("config.json")
        let configData = try Data(contentsOf: configURL)
        let config = try JSONDecoder().decode(HTDemucsConfig.self, from: configData)

        let model = HTDemucs(config: config)
        try model.update(parameters: ModuleParameters.unflattened(weights), verify: .noUnusedKeys)

        let output = model(input)

        assertArraysEqual(
            output,
            expectedOutput,
            tolerance: Self.modelTolerance,
            message: "Full model output mismatch"
        )
    }

    // MARK: - Shape Consistency Tests

    /// Verify that Swift model produces same shapes as Python.
    func testOutputShapeConsistency() throws {
        try skipIfNoFixtures()

        let fixtures = try loadFixture("small_model")

        let input = fixtures["input"]!
        let expectedOutput = fixtures["output"]!

        let configURL = Self.fixturesPath.appendingPathComponent("small_model_config.json")
        let configData = try Data(contentsOf: configURL)
        let config = try JSONDecoder().decode(HTDemucsConfig.self, from: configData)

        let model = HTDemucs(config: config)
        let output = model(input)

        XCTAssertEqual(
            output.shape,
            expectedOutput.shape,
            "Output shape mismatch: Swift \(output.shape) vs Python \(expectedOutput.shape)"
        )
    }
}

// MARK: - Errors

enum ParityTestError: Error, LocalizedError {
    case fixtureNotFound(String)

    var errorDescription: String? {
        switch self {
        case .fixtureNotFound(let name):
            return "Fixture not found: \(name).safetensors"
        }
    }
}

// MARK: - Performance Tests

extension HTDemucsParityTests {

    /// Benchmark forward pass performance.
    func testForwardPassPerformance() throws {
        // Use small config for benchmark
        var config = HTDemucsConfig()
        config.depth = 2
        config.channels = 16
        config.t_depth = 1
        config.bottom_channels = 32

        let model = HTDemucs(config: config)
        let input = MLXRandom.normal([1, 2, 44100])

        // Warmup
        _ = model(input)
        eval()

        measure {
            let _ = model(input)
            eval()
        }
    }
}
