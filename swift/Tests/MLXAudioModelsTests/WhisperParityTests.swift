// WhisperParityTests.swift
// Parity tests comparing Swift Whisper implementation against Python reference.
//
// These tests load fixtures generated by:
//   python tests/models/whisper/generate_swift_parity_data.py --output-dir swift/Tests/Fixtures/Whisper
//
// Run from the python/ directory to generate fixtures before running these tests.

import XCTest
import Foundation
import MLX
import MLXNN
@testable import MLXAudioModels

/// Parity tests for Whisper Swift implementation.
///
/// These tests compare Swift outputs against Python-generated fixtures
/// to ensure numerical equivalence within tolerance.
final class WhisperParityTests: XCTestCase {

    // MARK: - Test Configuration

    /// Tolerance for individual layer tests
    static let layerTolerance: Float = 1e-5

    /// Tolerance for multi-layer chains (accumulated error)
    static let chainTolerance: Float = 1e-4

    /// Tolerance for full model tests
    static let modelTolerance: Float = 1e-3

    /// Path to fixtures directory
    static var fixturesPath: URL {
        // Try environment variable first
        if let envPath = ProcessInfo.processInfo.environment["WHISPER_FIXTURES_PATH"] {
            return URL(fileURLWithPath: envPath)
        }

        // Common fixture locations to check
        let possiblePaths = [
            // Relative to source file
            URL(fileURLWithPath: #filePath)
                .deletingLastPathComponent()  // WhisperParityTests.swift
                .deletingLastPathComponent()  // MLXAudioModelsTests
                .deletingLastPathComponent()  // Tests
                .appendingPathComponent("Fixtures")
                .appendingPathComponent("Whisper"),

            // Current working directory patterns
            URL(fileURLWithPath: FileManager.default.currentDirectoryPath)
                .appendingPathComponent("Tests")
                .appendingPathComponent("Fixtures")
                .appendingPathComponent("Whisper"),

            URL(fileURLWithPath: FileManager.default.currentDirectoryPath)
                .appendingPathComponent("swift")
                .appendingPathComponent("Tests")
                .appendingPathComponent("Fixtures")
                .appendingPathComponent("Whisper"),

            // Common development paths
            URL(fileURLWithPath: NSHomeDirectory())
                .appendingPathComponent("Code/mlx-audio/swift/Tests/Fixtures/Whisper"),
        ]

        for path in possiblePaths {
            if FileManager.default.fileExists(atPath: path.path) {
                return path
            }
        }

        // Default fallback
        return possiblePaths[0]
    }

    /// Check if fixtures are available
    static var fixturesAvailable: Bool {
        FileManager.default.fileExists(atPath: fixturesPath.path)
    }

    // MARK: - Helper Methods

    /// Load arrays from a safetensors fixture file.
    func loadFixture(_ name: String) throws -> [String: MLXArray] {
        let url = Self.fixturesPath.appendingPathComponent("\(name).safetensors")
        guard FileManager.default.fileExists(atPath: url.path) else {
            throw WhisperParityTestError.fixtureNotFound(name)
        }
        return try MLX.loadArrays(url: url)
    }

    /// Load JSON config file.
    func loadConfig(_ name: String) throws -> [String: Any] {
        let url = Self.fixturesPath.appendingPathComponent("\(name).json")
        let data = try Data(contentsOf: url)
        guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any] else {
            throw WhisperParityTestError.invalidConfig(name)
        }
        return json
    }

    /// Calculate maximum absolute difference between two arrays.
    func maxAbsDiff(_ a: MLXArray, _ b: MLXArray) -> Float {
        let diff = abs(a - b)
        return diff.max().item(Float.self)
    }

    /// Calculate mean absolute difference between two arrays.
    func meanAbsDiff(_ a: MLXArray, _ b: MLXArray) -> Float {
        let diff = abs(a - b)
        return diff.mean().item(Float.self)
    }

    /// Assert arrays are equal within tolerance.
    func assertArraysEqual(
        _ actual: MLXArray,
        _ expected: MLXArray,
        tolerance: Float,
        message: String = "",
        file: StaticString = #file,
        line: UInt = #line
    ) {
        let diff = maxAbsDiff(actual, expected)
        XCTAssertLessThan(
            diff,
            tolerance,
            "Arrays differ by \(diff), exceeds tolerance \(tolerance). \(message)",
            file: file,
            line: line
        )
    }

    /// Skip test if fixtures not available.
    func skipIfNoFixtures(file: StaticString = #file, line: UInt = #line) throws {
        try XCTSkipUnless(
            Self.fixturesAvailable,
            "Fixtures not found at \(Self.fixturesPath.path). Run: python tests/models/whisper/generate_swift_parity_data.py",
            file: file,
            line: line
        )
    }

    // MARK: - Config Parity Tests

    func testConfigParity() throws {
        try skipIfNoFixtures()

        let configJson = try loadConfig("config")

        // Verify config matches
        let config = WhisperConfig.tiny()

        XCTAssertEqual(config.nMels, configJson["n_mels"] as? Int)
        XCTAssertEqual(config.nAudioCtx, configJson["n_audio_ctx"] as? Int)
        XCTAssertEqual(config.nAudioState, configJson["n_audio_state"] as? Int)
        XCTAssertEqual(config.nAudioHead, configJson["n_audio_head"] as? Int)
        XCTAssertEqual(config.nAudioLayer, configJson["n_audio_layer"] as? Int)
        XCTAssertEqual(config.nTextCtx, configJson["n_text_ctx"] as? Int)
        XCTAssertEqual(config.nTextState, configJson["n_text_state"] as? Int)
        XCTAssertEqual(config.nTextHead, configJson["n_text_head"] as? Int)
        XCTAssertEqual(config.nTextLayer, configJson["n_text_layer"] as? Int)
        XCTAssertEqual(config.nVocab, configJson["n_vocab"] as? Int)
    }

    // MARK: - Sinusoidal Embeddings Parity Tests

    func testSinusoidsParity() throws {
        try skipIfNoFixtures()

        let fixtures = try loadFixture("sinusoids")

        let pythonSinusoids = fixtures["output"]!
        let length = fixtures["length"]!.item(Int.self)
        let dim = fixtures["dim"]!.item(Int.self)

        // Generate Swift sinusoids
        let swiftSinusoids = sinusoids(length: length, dim: dim)

        // Verify shape
        XCTAssertEqual(swiftSinusoids.shape, pythonSinusoids.shape)

        // Verify values match
        assertArraysEqual(
            swiftSinusoids,
            pythonSinusoids,
            tolerance: Self.layerTolerance,
            message: "Sinusoidal embeddings mismatch"
        )
    }

    // MARK: - Encoder Parity Tests

    func testEncoderParity() throws {
        try skipIfNoFixtures()

        // Check if small model fixtures exist (has weights)
        let smallModelPath = Self.fixturesPath.appendingPathComponent("small_model.safetensors")
        try XCTSkipUnless(
            FileManager.default.fileExists(atPath: smallModelPath.path),
            "Small model fixtures not found"
        )

        let fixtures = try loadFixture("small_model")
        let weights = try loadFixture("small_model_weights")
        let configDict = try loadConfig("small_model_config")

        let melInput = fixtures["mel_input"]!
        let expectedOutput = fixtures["encoder_output"]!

        // Create config
        let config = WhisperConfig(
            nMels: configDict["n_mels"] as? Int ?? 80,
            nAudioCtx: configDict["n_audio_ctx"] as? Int ?? 1500,
            nAudioState: configDict["n_audio_state"] as? Int ?? 384,
            nAudioHead: configDict["n_audio_head"] as? Int ?? 6,
            nAudioLayer: configDict["n_audio_layer"] as? Int ?? 4,
            nTextCtx: configDict["n_text_ctx"] as? Int ?? 448,
            nTextState: configDict["n_text_state"] as? Int ?? 384,
            nTextHead: configDict["n_text_head"] as? Int ?? 6,
            nTextLayer: configDict["n_text_layer"] as? Int ?? 4,
            nVocab: configDict["n_vocab"] as? Int ?? 51865
        )

        let model = WhisperModel(config: config)
        try model.update(parameters: ModuleParameters.unflattened(weights), verify: .noUnusedKeys)

        // Run encoder
        let actualOutput = model.encode(melInput)

        // Compare
        assertArraysEqual(
            actualOutput,
            expectedOutput,
            tolerance: Self.chainTolerance,
            message: "Encoder output mismatch"
        )
    }

    // MARK: - Decoder Parity Tests

    func testDecoderNoCacheParity() throws {
        try skipIfNoFixtures()

        let smallModelPath = Self.fixturesPath.appendingPathComponent("small_model.safetensors")
        try XCTSkipUnless(
            FileManager.default.fileExists(atPath: smallModelPath.path),
            "Small model fixtures not found"
        )

        let fixtures = try loadFixture("small_model")
        let weights = try loadFixture("small_model_weights")
        let configDict = try loadConfig("small_model_config")

        let tokenInput = fixtures["token_input"]!
        let encoderOutput = fixtures["encoder_output"]!
        let expectedLogits = fixtures["logits"]!

        // Create config and model
        let config = WhisperConfig(
            nMels: configDict["n_mels"] as? Int ?? 80,
            nAudioCtx: configDict["n_audio_ctx"] as? Int ?? 1500,
            nAudioState: configDict["n_audio_state"] as? Int ?? 384,
            nAudioHead: configDict["n_audio_head"] as? Int ?? 6,
            nAudioLayer: configDict["n_audio_layer"] as? Int ?? 4,
            nTextCtx: configDict["n_text_ctx"] as? Int ?? 448,
            nTextState: configDict["n_text_state"] as? Int ?? 384,
            nTextHead: configDict["n_text_head"] as? Int ?? 6,
            nTextLayer: configDict["n_text_layer"] as? Int ?? 4,
            nVocab: configDict["n_vocab"] as? Int ?? 51865
        )

        let model = WhisperModel(config: config)
        try model.update(parameters: ModuleParameters.unflattened(weights), verify: .noUnusedKeys)

        // Run decoder
        let (actualLogits, _) = model.decode(tokens: tokenInput, audioFeatures: encoderOutput)

        // Compare
        assertArraysEqual(
            actualLogits,
            expectedLogits,
            tolerance: Self.chainTolerance,
            message: "Decoder output mismatch"
        )
    }

    // MARK: - Full Model Parity Tests

    func testFullModelParity() throws {
        try skipIfNoFixtures()

        let fullModelPath = Self.fixturesPath.appendingPathComponent("full_model.safetensors")
        try XCTSkipUnless(
            FileManager.default.fileExists(atPath: fullModelPath.path),
            "Full model fixtures not found"
        )

        let fixtures = try loadFixture("full_model")

        let melInput = fixtures["mel_input"]!
        let tokenInput = fixtures["token_input"]!
        let expectedLogits = fixtures["logits"]!

        // Check if we have weights (only for small model)
        let weightsPath = Self.fixturesPath.appendingPathComponent("small_model_weights.safetensors")
        if FileManager.default.fileExists(atPath: weightsPath.path) {
            let weights = try loadFixture("small_model_weights")
            let configDict = try loadConfig("small_model_config")

            let config = WhisperConfig(
                nMels: configDict["n_mels"] as? Int ?? 80,
                nAudioCtx: configDict["n_audio_ctx"] as? Int ?? 1500,
                nAudioState: configDict["n_audio_state"] as? Int ?? 384,
                nAudioHead: configDict["n_audio_head"] as? Int ?? 6,
                nAudioLayer: configDict["n_audio_layer"] as? Int ?? 4,
                nTextCtx: configDict["n_text_ctx"] as? Int ?? 448,
                nTextState: configDict["n_text_state"] as? Int ?? 384,
                nTextHead: configDict["n_text_head"] as? Int ?? 6,
                nTextLayer: configDict["n_text_layer"] as? Int ?? 4,
                nVocab: configDict["n_vocab"] as? Int ?? 51865
            )

            let model = WhisperModel(config: config)
            try model.update(parameters: ModuleParameters.unflattened(weights), verify: .noUnusedKeys)

            // Run full forward pass
            let actualLogits = model(mel: melInput, tokens: tokenInput)

            assertArraysEqual(
                actualLogits,
                expectedLogits,
                tolerance: Self.modelTolerance,
                message: "Full model output mismatch"
            )
        } else {
            // Just verify shape matches
            let config = WhisperConfig.tiny()
            let model = WhisperModel(config: config)

            let actualLogits = model(mel: melInput, tokens: tokenInput)

            XCTAssertEqual(
                actualLogits.shape,
                expectedLogits.shape,
                "Logits shape mismatch: Swift \(actualLogits.shape) vs Python \(expectedLogits.shape)"
            )
        }
    }

    // MARK: - Shape Consistency Tests

    func testOutputShapeConsistency() throws {
        try skipIfNoFixtures()

        let encoderFixtures = try loadFixture("encoder")

        let melInput = encoderFixtures["input"]!
        let expectedEncoderOutput = encoderFixtures["output"]!

        let config = WhisperConfig.tiny()
        let model = WhisperModel(config: config)

        let actualEncoderOutput = model.encode(melInput)

        XCTAssertEqual(
            actualEncoderOutput.shape,
            expectedEncoderOutput.shape,
            "Encoder output shape: Swift \(actualEncoderOutput.shape) vs Python \(expectedEncoderOutput.shape)"
        )
    }

    // MARK: - Tokenizer Tests

    func testTokenizerSpecialTokens() throws {
        try skipIfNoFixtures()

        let tokenizerInfo = try loadConfig("tokenizer_info")

        // These should match exactly (they're constants)
        XCTAssertEqual(50256, tokenizerInfo["eot"] as? Int)  // EOT is always 50256
        XCTAssertEqual(50257, tokenizerInfo["sot"] as? Int)  // SOT is always 50257
    }

    func testInitialTokens() throws {
        try skipIfNoFixtures()

        let initialTokensInfo = try loadConfig("initial_tokens")

        guard let transcribeEn = initialTokensInfo["transcribe_en_timestamps"] as? [Int] else {
            XCTFail("Could not parse initial tokens")
            return
        }

        // SOT should be first
        XCTAssertEqual(transcribeEn.first, 50257)

        // Should have language token, task token
        XCTAssertGreaterThan(transcribeEn.count, 2)
    }
}

// MARK: - Errors

enum WhisperParityTestError: Error, LocalizedError {
    case fixtureNotFound(String)
    case invalidConfig(String)

    var errorDescription: String? {
        switch self {
        case .fixtureNotFound(let name):
            return "Fixture not found: \(name).safetensors"
        case .invalidConfig(let name):
            return "Invalid config file: \(name).json"
        }
    }
}

// MARK: - Performance Tests

extension WhisperParityTests {

    /// Test that Swift encoder performance is reasonable.
    func testEncoderPerformance() throws {
        let config = WhisperConfig.tiny()
        let model = WhisperModel(config: config)

        // Warm up
        let warmupMel = MLXArray.zeros([1, config.nMels, 100])
        _ = model.encode(warmupMel)
        eval(model.parameters())

        // Benchmark
        let mel = MLXArray.zeros([1, config.nMels, 3000])  // ~30s of audio

        let start = CFAbsoluteTimeGetCurrent()
        let output = model.encode(mel)
        eval(output)
        let elapsed = CFAbsoluteTimeGetCurrent() - start

        print("Encoder time for 30s audio: \(elapsed * 1000)ms")

        // Should complete in reasonable time (< 5s for tiny model)
        XCTAssertLessThan(elapsed, 5.0, "Encoder too slow")
    }
}
