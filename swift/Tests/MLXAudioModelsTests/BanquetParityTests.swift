// BanquetParityTests.swift
// Parity tests comparing Swift Banquet implementation against Python.
//
// These tests load fixtures generated by:
//   python tests/generate_banquet_fixtures.py --output-dir swift/Tests/Fixtures/Banquet
//
// Run from the python/ directory to generate fixtures before running these tests.

import XCTest
@testable import MLXAudioModels
import MLX
import MLXAudioPrimitives
import MLXNN

/// Parity tests for Banquet Swift implementation.
///
/// These tests compare Swift outputs against Python-generated fixtures
/// to ensure numerical equivalence within tolerance.
final class BanquetParityTests: XCTestCase {

    // MARK: - Test Configuration

    /// Tolerance for individual layer tests
    static let layerTolerance: Float = 1e-4

    /// Tolerance for multi-layer chains (accumulated error)
    static let chainTolerance: Float = 1e-3

    /// Tolerance for full model tests
    static let modelTolerance: Float = 1e-2

    /// Minimum cosine similarity for embedding comparison
    static let cosineSimilarityThreshold: Float = 0.99

    /// Path to fixtures directory
    static var fixturesPath: URL {
        // Try environment variable first
        if let envPath = ProcessInfo.processInfo.environment["BANQUET_FIXTURES_PATH"] {
            return URL(fileURLWithPath: envPath)
        }

        // Common fixture locations to check
        let possiblePaths = [
            // Relative to source file
            URL(fileURLWithPath: #filePath)
                .deletingLastPathComponent()  // BanquetParityTests.swift
                .deletingLastPathComponent()  // MLXAudioModelsTests
                .deletingLastPathComponent()  // Tests
                .appendingPathComponent("Fixtures")
                .appendingPathComponent("Banquet"),

            // Current working directory patterns
            URL(fileURLWithPath: FileManager.default.currentDirectoryPath)
                .appendingPathComponent("Tests")
                .appendingPathComponent("Fixtures")
                .appendingPathComponent("Banquet"),

            URL(fileURLWithPath: FileManager.default.currentDirectoryPath)
                .appendingPathComponent("swift")
                .appendingPathComponent("Tests")
                .appendingPathComponent("Fixtures")
                .appendingPathComponent("Banquet"),

            // Common development paths
            URL(fileURLWithPath: NSHomeDirectory())
                .appendingPathComponent("Code/mlx-audio/swift/Tests/Fixtures/Banquet"),
        ]

        for path in possiblePaths {
            if FileManager.default.fileExists(atPath: path.path) {
                return path
            }
        }

        // Default fallback
        return possiblePaths[0]
    }

    /// Check if fixtures are available
    static var fixturesAvailable: Bool {
        FileManager.default.fileExists(atPath: fixturesPath.path)
    }

    // MARK: - Helper Methods

    /// Load arrays from a safetensors fixture file.
    func loadFixture(_ name: String) throws -> [String: MLXArray] {
        let url = Self.fixturesPath.appendingPathComponent("\(name).safetensors")
        guard FileManager.default.fileExists(atPath: url.path) else {
            throw BanquetParityTestError.fixtureNotFound(name)
        }
        return try MLX.loadArrays(url: url)
    }

    /// Load JSON config file.
    func loadConfig(_ name: String) throws -> [String: Any] {
        let url = Self.fixturesPath.appendingPathComponent("\(name).json")
        let data = try Data(contentsOf: url)
        guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any] else {
            throw BanquetParityTestError.invalidConfig(name)
        }
        return json
    }

    /// Calculate maximum absolute difference between two arrays.
    func maxAbsDiff(_ a: MLXArray, _ b: MLXArray) -> Float {
        let diff = abs(a - b)
        return diff.max().item(Float.self)
    }

    /// Calculate mean absolute difference between two arrays.
    func meanAbsDiff(_ a: MLXArray, _ b: MLXArray) -> Float {
        let diff = abs(a - b)
        return diff.mean().item(Float.self)
    }

    /// Calculate cosine similarity between two arrays.
    func cosineSimilarity(_ a: MLXArray, _ b: MLXArray) -> Float {
        let aFlat = a.reshaped([-1])
        let bFlat = b.reshaped([-1])
        let dot = sum(aFlat * bFlat)
        let normA = sqrt(sum(aFlat * aFlat))
        let normB = sqrt(sum(bFlat * bFlat))
        return (dot / (normA * normB)).item(Float.self)
    }

    /// Assert arrays are equal within tolerance.
    func assertArraysEqual(
        _ actual: MLXArray,
        _ expected: MLXArray,
        tolerance: Float,
        message: String = "",
        file: StaticString = #file,
        line: UInt = #line
    ) {
        let diff = maxAbsDiff(actual, expected)
        XCTAssertLessThan(
            diff,
            tolerance,
            "Arrays differ by \(diff), exceeds tolerance \(tolerance). \(message)",
            file: file,
            line: line
        )
    }

    /// Assert embeddings are similar using cosine similarity.
    func assertEmbeddingsSimilar(
        _ actual: MLXArray,
        _ expected: MLXArray,
        threshold: Float = 0.99,
        message: String = "",
        file: StaticString = #file,
        line: UInt = #line
    ) {
        let similarity = cosineSimilarity(actual, expected)
        XCTAssertGreaterThan(
            similarity,
            threshold,
            "Cosine similarity \(similarity) below threshold \(threshold). \(message)",
            file: file,
            line: line
        )
    }

    /// Skip test if fixtures not available.
    func skipIfNoFixtures(file: StaticString = #file, line: UInt = #line) throws {
        try XCTSkipUnless(
            Self.fixturesAvailable,
            "Fixtures not found at \(Self.fixturesPath.path). Run: python tests/generate_banquet_fixtures.py",
            file: file,
            line: line
        )
    }

    // MARK: - FiLM Parity Tests

    func testFiLMParity() throws {
        try skipIfNoFixtures()

        let fixturesPath = Self.fixturesPath.appendingPathComponent("film.safetensors")
        try XCTSkipUnless(
            FileManager.default.fileExists(atPath: fixturesPath.path),
            "FiLM fixtures not found"
        )

        let fixtures = try loadFixture("film")
        let weights = try loadFixture("film_weights")
        let configDict = try loadConfig("film_config")

        let input = fixtures["input"]!
        let conditioning = fixtures["conditioning"]!
        let expectedOutput = fixtures["output"]!

        // Create FiLM with same config
        let film = FiLM(
            condEmbeddingDim: configDict["cond_embedding_dim"] as? Int ?? 768,
            channels: configDict["channels"] as? Int ?? 128,
            additive: configDict["additive"] as? Bool ?? true,
            multiplicative: configDict["multiplicative"] as? Bool ?? true,
            depth: configDict["depth"] as? Int ?? 2,
            channelsPerGroup: configDict["channels_per_group"] as? Int ?? 16
        )

        // Load weights
        try film.update(parameters: ModuleParameters.unflattened(weights), verify: .noUnusedKeys)

        // Run forward pass
        let output = film(input, conditioning: conditioning)

        // Compare
        assertArraysEqual(
            output,
            expectedOutput,
            tolerance: Self.layerTolerance,
            message: "FiLM output mismatch"
        )
    }

    // MARK: - BandSplit Parity Tests

    func testBandSplitParity() throws {
        try skipIfNoFixtures()

        let fixturesPath = Self.fixturesPath.appendingPathComponent("bandsplit.safetensors")
        try XCTSkipUnless(
            FileManager.default.fileExists(atPath: fixturesPath.path),
            "BandSplit fixtures not found"
        )

        let fixtures = try loadFixture("bandsplit")
        let weights = try loadFixture("bandsplit_weights")
        let configDict = try loadConfig("bandsplit_config")

        let inputReal = fixtures["input_real"]!
        let inputImag = fixtures["input_imag"]!
        let expectedOutput = fixtures["output"]!

        // Create complex input
        let input = ComplexArray(real: inputReal, imag: inputImag)

        // Generate band specs
        let nFFT = configDict["n_fft"] as? Int ?? 2048
        let sampleRate = configDict["sample_rate"] as? Int ?? 44100
        let nBands = configDict["n_bands"] as? Int ?? 16
        let inChannel = configDict["in_channel"] as? Int ?? 2
        let embDim = configDict["emb_dim"] as? Int ?? 128

        let bandSpec = MusicalBandsplitSpecificationWithWeights(
            nFFT: nFFT,
            sampleRate: sampleRate,
            nBands: nBands
        )

        let bandSplit = BandSplitModule(
            inChannel: inChannel,
            bandSpecs: bandSpec.bandSpecs,
            embDim: embDim
        )

        // Load weights
        try bandSplit.update(parameters: ModuleParameters.unflattened(weights), verify: .noUnusedKeys)

        // Run forward pass
        let output = bandSplit(input)

        // Compare
        assertArraysEqual(
            output,
            expectedOutput,
            tolerance: Self.layerTolerance,
            message: "BandSplit output mismatch"
        )
    }

    // MARK: - SeqBandModelling Parity Tests

    func testSeqBandParity() throws {
        try skipIfNoFixtures()

        let fixturesPath = Self.fixturesPath.appendingPathComponent("seqband.safetensors")
        try XCTSkipUnless(
            FileManager.default.fileExists(atPath: fixturesPath.path),
            "SeqBand fixtures not found"
        )

        let fixtures = try loadFixture("seqband")
        let configDict = try loadConfig("seqband_config")

        let input = fixtures["input"]!
        let expectedOutput = fixtures["output"]!

        // Create SeqBandModelling
        let seqBand = SeqBandModellingModule(
            nModules: configDict["n_modules"] as? Int ?? 2,
            embDim: configDict["emb_dim"] as? Int ?? 64,
            rnnDim: configDict["rnn_dim"] as? Int ?? 128,
            bidirectional: configDict["bidirectional"] as? Bool ?? true,
            rnnType: configDict["rnn_type"] as? String ?? "LSTM"
        )

        // Note: LSTM weights are complex to transfer, so we mainly verify shapes
        // For full weight parity, we'd need more sophisticated weight mapping

        // Run forward pass (with random weights)
        let output = seqBand(input)

        // Verify shape matches
        XCTAssertEqual(
            output.shape,
            expectedOutput.shape,
            "SeqBand output shape mismatch: Swift \(output.shape) vs Python \(expectedOutput.shape)"
        )
    }

    // MARK: - PaSST Parity Tests

    func testPaSSTShapeParity() throws {
        try skipIfNoFixtures()

        let fixturesPath = Self.fixturesPath.appendingPathComponent("passt.safetensors")
        try XCTSkipUnless(
            FileManager.default.fileExists(atPath: fixturesPath.path),
            "PaSST fixtures not found"
        )

        let fixtures = try loadFixture("passt")
        let configDict = try loadConfig("passt_config")

        let input = fixtures["input"]!
        let expectedOutput = fixtures["output"]!

        // Create PaSST with same config
        let config = PaSSTConfig(
            embedDim: configDict["embed_dim"] as? Int ?? 256,
            numHeads: configDict["num_heads"] as? Int ?? 4,
            numLayers: configDict["num_layers"] as? Int ?? 2,
            mlpRatio: Float(configDict["mlp_ratio"] as? Double ?? 2.0)
        )

        let passt = PaSST(config: config)

        // Run forward pass (with random weights - verify shape)
        let output = passt(input)

        // Verify shape matches
        XCTAssertEqual(
            output.shape,
            expectedOutput.shape,
            "PaSST output shape mismatch: Swift \(output.shape) vs Python \(expectedOutput.shape)"
        )
    }

    // MARK: - MaskEstimation Parity Tests

    func testMaskEstimationParity() throws {
        try skipIfNoFixtures()

        let fixturesPath = Self.fixturesPath.appendingPathComponent("maskestim.safetensors")
        try XCTSkipUnless(
            FileManager.default.fileExists(atPath: fixturesPath.path),
            "MaskEstimation fixtures not found"
        )

        let fixtures = try loadFixture("maskestim")
        let configDict = try loadConfig("maskestim_config")

        let input = fixtures["input"]!
        let expectedOutput = fixtures["output"]!

        // Generate band specs
        let nFreq = configDict["n_freq"] as? Int ?? 1025
        let nBands = configDict["n_bands"] as? Int ?? 16
        let inChannel = configDict["in_channel"] as? Int ?? 2
        let embDim = configDict["emb_dim"] as? Int ?? 64
        let mlpDim = configDict["mlp_dim"] as? Int ?? 128

        let bandSpec = MusicalBandsplitSpecificationWithWeights(
            nFFT: (nFreq - 1) * 2,
            sampleRate: 44100,
            nBands: nBands
        )

        let maskEstim = OverlappingMaskEstimationModule(
            inChannel: inChannel,
            bandSpecs: bandSpec.bandSpecs,
            freqWeights: bandSpec.freqWeights,
            nFreq: nFreq,
            embDim: embDim,
            mlpDim: mlpDim,
            complexMask: configDict["complex_mask"] as? Bool ?? true
        )

        // Run forward pass (with random weights - verify shape)
        let output = maskEstim(input)

        // Verify shape matches
        XCTAssertEqual(
            output.shape,
            expectedOutput.shape,
            "MaskEstimation output shape mismatch: Swift \(output.shape) vs Python \(expectedOutput.shape)"
        )
    }

    // MARK: - Small Model Integration Test

    func testSmallModelShapeParity() throws {
        try skipIfNoFixtures()

        let fixturesPath = Self.fixturesPath.appendingPathComponent("small_model.safetensors")
        try XCTSkipUnless(
            FileManager.default.fileExists(atPath: fixturesPath.path),
            "Small model fixtures not found"
        )

        let fixtures = try loadFixture("small_model")
        let configDict = try loadConfig("small_model_config")

        let mixture = fixtures["mixture"]!
        let queryEmbedding = fixtures["query_embedding"]!
        let expectedAudio = fixtures["output_audio"]!
        let expectedMask = fixtures["output_mask"]!

        // Parse configs
        guard let banquetDict = configDict["banquet"] as? [String: Any],
              let passtDict = configDict["passt"] as? [String: Any] else {
            throw BanquetParityTestError.invalidConfig("small_model_config")
        }

        let config = BanquetConfig(
            nBands: banquetDict["n_bands"] as? Int ?? 8,
            embDim: banquetDict["emb_dim"] as? Int ?? 32,
            rnnDim: banquetDict["rnn_dim"] as? Int ?? 64,
            nSQMModules: banquetDict["n_sqm_modules"] as? Int ?? 1,
            mlpDim: banquetDict["mlp_dim"] as? Int ?? 64,
            condEmbDim: banquetDict["cond_emb_dim"] as? Int ?? 128
        )

        let passtConfig = PaSSTConfig(
            embedDim: passtDict["embed_dim"] as? Int ?? 128,
            numHeads: passtDict["num_heads"] as? Int ?? 2,
            numLayers: passtDict["num_layers"] as? Int ?? 1,
            mlpRatio: Float(passtDict["mlp_ratio"] as? Double ?? 2.0)
        )

        let model = Banquet(config: config, passtConfig: passtConfig)

        // Run forward pass (with random weights)
        let output = try model(mixture, queryEmbedding: queryEmbedding)

        // Verify shapes match
        XCTAssertEqual(
            output.audio.shape,
            expectedAudio.shape,
            "Audio output shape mismatch: Swift \(output.audio.shape) vs Python \(expectedAudio.shape)"
        )

        XCTAssertEqual(
            output.mask.shape,
            expectedMask.shape,
            "Mask output shape mismatch: Swift \(output.mask.shape) vs Python \(expectedMask.shape)"
        )
    }

    // MARK: - Query Preparation Test

    func testPrepareQueryMel() throws {
        // Test that prepareQueryMel produces correct output shape
        let sampleRate = 44100
        let duration: Float = 1.0  // 1 second
        let samples = Int(Float(sampleRate) * duration)

        // Create test audio
        let audio = MLXRandom.normal([samples])

        // Prepare mel spectrogram
        let mel = try prepareQueryMel(
            audio,
            sampleRate: sampleRate,
            targetSampleRate: 32000,
            nMels: 128
        )

        // Verify shape: [1, 1, n_mels, time]
        XCTAssertEqual(mel.shape[0], 1, "Batch dimension should be 1")
        XCTAssertEqual(mel.shape[1], 1, "Channel dimension should be 1")
        XCTAssertEqual(mel.shape[2], 128, "Mel bins should be 128")
        XCTAssertGreaterThan(mel.shape[3], 0, "Time dimension should be positive")
    }

    func testPrepareQueryMelStereo() throws {
        // Test with stereo input
        let sampleRate = 44100
        let duration: Float = 0.5
        let samples = Int(Float(sampleRate) * duration)

        // Create stereo test audio
        let audio = MLXRandom.normal([2, samples])

        // Prepare mel spectrogram (should convert to mono)
        let mel = try prepareQueryMel(audio, sampleRate: sampleRate)

        // Verify shape
        XCTAssertEqual(mel.shape[0], 1, "Batch dimension should be 1")
        XCTAssertEqual(mel.shape[1], 1, "Channel dimension should be 1")
        XCTAssertEqual(mel.shape[2], 128, "Mel bins should be 128")
    }

    // MARK: - Chunked Inference Test

    func testChunkedInference() throws {
        // Create a small model for testing
        let config = BanquetConfig(
            nBands: 8,
            embDim: 32,
            rnnDim: 64,
            nSQMModules: 1,
            mlpDim: 64
        )
        let passtConfig = PaSSTConfig(
            embedDim: 128,
            numHeads: 2,
            numLayers: 1
        )

        let model = Banquet(config: config, passtConfig: passtConfig)

        // Create long audio (3 seconds at 44.1kHz)
        let samples = 44100 * 3
        let mixture = MLXRandom.normal([2, samples]) * 0.1
        let queryEmbedding = MLXRandom.normal([128]) * 0.1

        // Run chunked inference with 1 second segments
        let result = try applyBanquetModel(
            model,
            mixture: mixture,
            queryEmbedding: queryEmbedding,
            segment: 1.0,
            overlap: 0.25,
            split: true
        )

        // Verify output shape matches input
        XCTAssertEqual(result.audio.shape[0], 2, "Output should be stereo")
        XCTAssertEqual(result.audio.shape[1], samples, "Output length should match input")
    }
}

// MARK: - Errors

enum BanquetParityTestError: Error, LocalizedError {
    case fixtureNotFound(String)
    case invalidConfig(String)

    var errorDescription: String? {
        switch self {
        case .fixtureNotFound(let name):
            return "Fixture not found: \(name).safetensors"
        case .invalidConfig(let name):
            return "Invalid config file: \(name).json"
        }
    }
}

// MARK: - Performance Tests

extension BanquetParityTests {

    /// Benchmark FiLM forward pass.
    func testFiLMPerformance() throws {
        let film = FiLM(
            condEmbeddingDim: 768,
            channels: 128,
            additive: true,
            multiplicative: true,
            depth: 2,
            channelsPerGroup: 16
        )

        let x = MLXRandom.normal([1, 128, 64, 100])
        let w = MLXRandom.normal([1, 768])

        // Warmup
        _ = film(x, conditioning: w)
        eval()

        measure {
            _ = film(x, conditioning: w)
            eval()
        }
    }

    /// Benchmark PaSST forward pass.
    func testPaSSTPerformance() throws {
        let config = PaSSTConfig(
            embedDim: 768,
            numHeads: 12,
            numLayers: 4  // Reduced for faster benchmark
        )
        let passt = PaSST(config: config)

        let input = MLXRandom.normal([1, 1, 128, 998])

        // Warmup
        _ = passt(input)
        eval()

        measure {
            _ = passt(input)
            eval()
        }
    }
}
